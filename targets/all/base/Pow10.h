/*
 * Copyright (c) 2025 triaxis s.r.o.
 * Licensed under the MIT license. See LICENSE.txt file in the repository root
 * for full license information.
 *
 * base/Pow10.h
 *
 * Helper class for conversion between binary and decimal exponents
 * used by atof and ftoa conversions
 *
 * Do not edit, this file is generated by Pow10.js in the same directory
 */

#pragma once

#include <base/base.h>

class Pow10
{
public:
    // configure an instance for the specified decimal exponent
    ALWAYS_INLINE Pow10(int k)
    {
        // precalculated decimal exponents
        static const uint32_t p10f[] =
        {
            // 10^-53 through 10^-1
            0xf5330400, 0x993fe2c0, 0xbf8fdb78, 0xef73d256, 0x95a86376, 0xbb127c53, 0xe9d71b68, 0x92267121, 0xb6b00d69, 0xe45c10c4, 0x8eb98a7a, 0xb267ed19, 0xdf01e85f, 0x8b61313b, 0xae397d8a, 0xd9c7dced, 0x881cea14, 0xaa242499, 0xd4ad2dbf, 0x84ec3c97, 0xa6274bbd, 0xcfb11ead, 0x81ceb32c, 0xa2425ff7, 0xcad2f7f5, 0xfd87b5f2, 0x9e74d1b7, 0xc6120625, 0xf79687ae, 0x9abe14cd, 0xc16d9a00, 0xf1c90080, 0x971da050, 0xbce50864, 0xec1e4a7d, 0x9392ee8e, 0xb877aa32, 0xe69594be, 0x901d7cf7, 0xb424dc35, 0xe12e1342, 0x8cbccc09, 0xafebff0b, 0xdbe6fece, 0x89705f41, 0xabcc7711, 0xd6bf94d5, 0x8637bd05, 0xa7c5ac47, 0xd1b71758, 0x83126e97, 0xa3d70a3d, 0xcccccccc,
            // 10^0 through 10^53
            0x80000000, 0xa0000000, 0xc8000000, 0xfa000000, 0x9c400000, 0xc3500000, 0xf4240000, 0x98968000, 0xbebc2000, 0xee6b2800, 0x9502f900, 0xba43b740, 0xe8d4a510, 0x9184e72a, 0xb5e620f4, 0xe35fa931, 0x8e1bc9bf, 0xb1a2bc2e, 0xde0b6b3a, 0x8ac72304, 0xad78ebc5, 0xd8d726b7, 0x87867832, 0xa968163f, 0xd3c21bce, 0x84595161, 0xa56fa5b9, 0xcecb8f27, 0x813f3978, 0xa18f07d7, 0xc9f2c9cd, 0xfc6f7c40, 0x9dc5ada8, 0xc5371912, 0xf684df56, 0x9a130b96, 0xc097ce7b, 0xf0bdc21a, 0x96769950, 0xbc143fa4, 0xeb194f8e, 0x92efd1b8, 0xb7abc627, 0xe596b7b0, 0x8f7e32ce, 0xb35dbf82, 0xe0352f62, 0x8c213d9d, 0xaf298d05, 0xdaf3f046, 0x88d8762b, 0xab0e93b6, 0xd5d238a4, 0x85a36366,
        };

        // corresponding binary exponents (all positive to fit a byte, negative are compensated below)
        static const uint8_t p10e[] =
        {
            // 10^-53 through 10^-1
            176, 172, 169, 166, 162, 159, 156, 152, 149, 146, 142, 139, 136, 132, 129, 126, 122, 119, 116, 112, 109, 106, 102, 99, 96, 93, 89, 86, 83, 79, 76, 73, 69, 66, 63, 59, 56, 53, 49, 46, 43, 39, 36, 33, 29, 26, 23, 19, 16, 13, 9, 6, 3,
            // 10^0 through 10^53
            1, 4, 7, 10, 14, 17, 20, 24, 27, 30, 34, 37, 40, 44, 47, 50, 54, 57, 60, 64, 67, 70, 74, 77, 80, 84, 87, 90, 94, 97, 100, 103, 107, 110, 113, 117, 120, 123, 127, 130, 133, 137, 140, 143, 147, 150, 153, 157, 160, 163, 167, 170, 173, 177,
        };

        unsigned index = k + 53;
        if (index < countof(p10f))
        {
            f = p10f[index];
            e = k < 0 ? -p10e[index] : p10e[index];
        }
        else
        {
            f = 0;
            e = 0;
        }
    }

    enum { Min = -53, Max = 53 };

    //! Checks whether conversion is supported
    constexpr bool IsValid() const { return !!f; }
    //! Get the decimal exponent of this instance
    constexpr int Exponent() const { return e; }
    //! Apply the conversion to the specified value - the decimal point is between high and low words of the result
    constexpr uint64_t Multiply64(uint32_t v) const { return (v * uint64_t(f)); }
    //! Apply the conversion to the specified value - the result is the whole part of the result
    constexpr uint32_t Multiply32(uint32_t v) const { return (v * uint64_t(f)) >> 32; }

private:
    uint32_t f;
    int e;
};

