#!/usr/bin/env node

// symmetric ends, so we can use the table for both ftoa and atof
const start = -53
const end = 53
const maxBits = 300
const maxBase = 2n ** BigInt(maxBits)
const outBits = 32
const roundUp = true

const f = [], e = []

for (let i = BigInt(start); i <= BigInt(end); i++) {
    const n = i < 0 ? maxBase / (10n ** -i) : 10n ** i;
    const bits = n.toString(2)

    e.push(i < 0 ? bits.length - maxBits : bits.length)
    if (roundUp) {
        f.push(BigInt('0b' + bits.substring(0, outBits + 1).padEnd(outBits + 1, '0')) + 1n >> 1n)
    } else {
        f.push(BigInt('0b' + bits.substring(0, outBits).padEnd(outBits, '0')))
    }
}

const fmap = n => `0x${n.toString(16)}`;
const emap = n => Math.abs(n);

console.log(
`/*
 * Copyright (c) 2025 triaxis s.r.o.
 * Licensed under the MIT license. See LICENSE.txt file in the repository root
 * for full license information.
 *
 * base/Pow10.h
 *
 * Helper class for conversion between binary and decimal exponents
 * used by atof and ftoa conversions
 *
 * Do not edit, this file is generated by Pow10.js in the same directory
 */

#pragma once

#include <base/base.h>

class Pow10
{
public:
    // configure an instance for the specified decimal exponent
    ALWAYS_INLINE Pow10(int k)
    {
        // precalculated decimal exponents
        static const uint32_t p10f[] =
        {
            // 10^${start} through 10^-1
            ${f.slice(0, -start).map(fmap).join(', ')},
            // 10^0 through 10^${end}
            ${f.slice(-start).map(fmap).join(', ')},
        };

        // corresponding binary exponents (all positive to fit a byte, negative are compensated below)
        static const uint8_t p10e[] =
        {
            // 10^${start} through 10^-1
            ${e.slice(0, -start).map(emap).join(', ')},
            // 10^0 through 10^${end}
            ${e.slice(-start).map(emap).join(', ')},
        };

        unsigned index = k + ${-start};
        if (index < countof(p10f))
        {
            f = p10f[index];
            e = k < 0 ? -p10e[index] : p10e[index];
        }
        else
        {
            f = 0;
            e = 0;
        }
    }

    enum { Min = ${start}, Max = ${end} };

    //! Checks whether conversion is supported
    constexpr bool IsValid() const { return !!f; }
    //! Get the decimal exponent of this instance
    constexpr int Exponent() const { return e; }
    //! Apply the conversion to the specified value - the decimal point is between high and low words of the result
    constexpr uint64_t Multiply(uint32_t v) const { return (v * uint64_t(f)); }

private:
    uint32_t f;
    int e;
};
`)
